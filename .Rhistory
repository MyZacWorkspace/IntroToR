knitr::opts_chunk$set(echo = TRUE)
plot(pressure)
library(readr)
seventeen <- read_csv("Desktop/Work/Stats/data/seventeen.csv")
View(seventeen)
knitr::opts_chunk$set(echo = TRUE)
library(mosaic)
install.packages("mosaic")
library(mosaic)
plot(seventeen$rav, seventeen$rof)
library(mosaic)
plot(seventeen$rav, seventeen$rof)
cor(seventeen$rav, seventeen$rof)
a=lm(rof~rav)
library(mosaic)
plot(seventeen$rav, seventeen$rof)
cor(seventeen$rav, seventeen$rof)
a=lm(seventeen$rof~seventeen$rav)
summary(a)
CLAIM5 <- read.csv("~/Desktop/Work/CLAIM5.csv")
View(CLAIM5)
knitr::opts_chunk$set(echo = TRUE)
#CLAIM 5
library(mosaic)
library(stats)
z.test(CLAIM5$On2,CLAIM5$Off2 ,mu = 0, alternative = "less", var.equal)
b<- data.frame(c(1,2) , c("L" , "R"))
b
typeof(b)
class(b)
class(vector())
is.datatype(vector())
str(vectot())
str(vector())
str(matrix)
str(matrix())
?sapply
sapply(1:9, factorial)
state.area
iris
class(iris)
iris[1]
class(iris[1])
iris$Sepal.Length
class(iris$Sepal.Length)
class(iris['Sepal.Length'])
iris['Sepal.Length']
# sort the vector to get largest to smallest
# check to see where indices match
# because of built-in vectorization causing unintentional recycling, a for-loop needs to be implemented
# NOT: NAME[PCTPOPCHG == sort(pct.pop.change, decreasing = TRUE)[1:5]]
state.pop[order(state.pop$PCTPOPCHG, decreasing=TRUE), c(2, 7)]
state.pop <- read.csv("2020_2023_state_region_pop.csv")
setwd("~/Desktop/IntroToR")
state.pop <- read.csv("2020_2023_state_region_pop.csv")
str(state.pop)
attach(state.pop)
pct.pop.change <- (POPESTIMATE2023 - POPESTIMATE2020)*100/POPESTIMATE2020
state.pop$PCTPOPCHG <- pct.pop.change
attach(state.pop)
attach(state.pop)
top5inc <- vector(mode = "numeric" , length = 5)
for(i in 1:5)
{
top5inc[i] <- which(PCTPOPCHG == sort(PCTPOPCHG , decreasing = TRUE)[i])
}
cat("Top 5 State Population Increase" , "\n")
cat(paste(NAME[top5inc], "increased by: ", sort(PCTPOPCHG , decreasing = TRUE)[1:5], "%"), sep = "\n")
state.pop[order(state.pop$PCTPOPCHG, decreasing=TRUE), c(2, 7)]
